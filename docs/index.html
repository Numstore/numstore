<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numstore - Database for Contiguous Bytes</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <img src="logo.svg" alt="Numstore Logo" class="logo">
        <h1>Numstore</h1>
        <p>A high-performance database for raster data and contiguous byte streams</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="getting-started.html">Getting Started</a></li>
            <li><a href="features.html">Features</a></li>
            <li><a href="api-reference.html">API Reference</a></li>
            <li><a href="configuration.html">Configuration</a></li>
            <li><a href="examples.html">Examples</a></li>
            <li><a href="downloads.html">Downloads</a></li>
            <li><a href="about.html">About</a></li>
        </ul>
    </nav>

    <main>

      <section class="section">
            <h2>What is Numstore?</h2>
            <p>
                You're a solar physicist with this typical workflow:
                <ul>
                  <li>
                    Pull massive image blobs from JSOC's collection of solar active regions.
                    Store them as FITS files scattered across your filesystem.
                  </li>
                  <li>
                    Iterate through thousands of files, rewriting the same boilerplate:
                    <pre><code>data = fits.getdata('hmi.sharp_720s.7115.20170906_000000_TAI.magnetogram.fits')
plt.imshow(data)  # Does this look right?</code></pre>
                  </li>
                  <li>
                    Build a dataset of specific subregions‚Äîsay, all 512√ó512 patches where the
                    magnetic field exceeds 1000 Gauss. Now you're managing indices in spreadsheets
                    and praying your filenames stay consistent.
                  </li>
                </ul>
                Numstore stores your magnetograms as contiguous byte arrays with spatial indexing built in.
                Query by bounding box, magnetic field threshold, timestamp‚ÄîO(log N) every time. No filesystem
                archaeology required.
            </p>
            <p>
                You're a DSP engineer building a software-defined radio:
                <ul>
                  <li>
                    Your application captures IQ samples at 100 MHz for 10 seconds. That's 2 billion
                    float32 values (8 GB of complex samples).
                  </li>
                  <li>
                    Where do you store this? Postgres with 2 billion rows? Insane. A single BYTEA blob?
                    Sure, but now you can't efficiently extract "samples 50M through 51M" without reading
                    the entire 8 GB into memory.
                  </li>
                  <li>
                    You need random access to arbitrary ranges. You need to insert calibration samples
                    or apply filters without rewriting the whole file. Traditional databases weren't
                    built for this.
                  </li>
                </ul>
                Numstore ingests binary streams at 640+ MB/s and indexes them for O(log N) random access.
                Read samples [50000000:51000000]. Overwrite bytes at offset 12345678. Insert a header
                in the middle. It's a B+Tree that thinks in bytes, not rows.
            </p>
            <p>
                You're an embedded engineer parsing telemetry:
                <ul>
                  <li>
                    Your CAN bus packets arrive as <code>[5 bytes header][10 bytes payload][11 bytes footer]</code>.
                  </li>
                  <li>
                    You're storing millions of these. You need to query "all packets where byte 7 equals 0xFF"
                    or "extract the footer from packets 1000-2000."
                  </li>
                  <li>
                    Flat files work until you need to search. Relational databases work until you realize
                    you're fighting the type system to store raw binary. You end up writing your own
                    index in a JSON file.
                  </li>
                </ul>
                Numstore lets you define your packet as a 26-byte record and store millions of them.
                Spatial indexing means "find all packets with header[2] &gt; 128" runs in logarithmic time.
                The database understands byte offsets natively‚Äîno ORM impedance mismatch.
            </p>
            <p>
                Numstore uses an R+Tree‚Äîa spatial index optimized for one-dimensional byte ranges.
                Think B+Tree, but every node tracks its byte count for O(log N) operations anywhere
                in the stream. Insert 1 MB at offset 500 GB? Rebalance a few nodes. Delete bytes
                [12000000:13000000]? Logarithmic. It's designed for data that traditional databases
                treat as an afterthought: raw binary streams that need database-grade indexing.
            </p>
        </section>

        <section class="section">
            <h2>Key Features</h2>
            <div class="feature-grid">
                <div class="feature-box">
                    <h3>üöÄ High Performance</h3>
                    <p>Sustained write speeds exceed 640 MB/s with log N time complexity for all operations.</p>
                </div>
                <div class="feature-box">
                    <h3>üíæ Persistent Storage</h3>
                    <p>Automatic persistence with undo redo write-ahead logging (WAL) using ARIES.</p>
                </div>
                <div class="feature-box">
                    <h3>üîÑ Transaction Support</h3>
                    <p>ACID transactions for data consistency with automatic crash recovery.</p>
                </div>
                <div class="feature-box">
                    <h3>üåê Multi-Language Support</h3>
                    <p>Native C library with Python and Java bindings.</p>
                </div>
                <div class="feature-box">
                    <h3>‚ö° Flexible Access</h3>
                    <p>Support for strided reads/writes and offset-based operations.</p>
                </div>
                <div class="feature-box">
                    <h3>üõ°Ô∏è Crash Recovery</h3>
                    <p>Automatic recovery from unexpected failures.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Quick Start</h2>
            <p>Get started with Numstore in minutes:</p>
            <pre><code># Clone the repository
git clone https://gitlab.com/lincketheo/numstore.git
cd numstore

# Build the project
make

# Run tests
./build/debug/apps/test</code></pre>
            <p><a href="getting-started.html">View detailed getting started guide ‚Üí</a></p>
        </section>

        <section class="section">
            <h2>Use Cases</h2>
            <p>Numstore is ideal for:</p>
            <ul>
                <li>Scientific data storage with efficient random access</li>
                <li>Time-series databases requiring fast insertions and reads</li>
                <li>Machine learning datasets with complex access patterns</li>
                <li>Engineering simulations requiring large contiguous data structures</li>
                <li>Applications needing log N insertions/deletions in byte streams</li>
            </ul>
        </section>

        <section class="section">
            <h2>Documentation</h2>
            <ul>
                <li><a href="getting-started.html">Getting Started Guide</a> - Installation and basic usage</li>
                <li><a href="features.html">Features Overview</a> - Complete feature list and capabilities</li>
                <li><a href="api-reference.html">API Reference</a> - Detailed API documentation</li>
                <li><a href="configuration.html">Configuration</a> - System and variable configuration options</li>
                <li><a href="examples.html">Examples</a> - Code examples and tutorials</li>
                <li><a href="types.html">Type System</a> - Understanding Numstore's type system</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>Copyright 2025 Theo Lincke | Licensed under the Apache License 2.0</p>
        <p><a href="https://gitlab.com/lincketheo/numstore">GitHub Repository</a></p>
    </footer>
</body>
</html>
