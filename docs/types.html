<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type System - Numstore Documentation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Numstore Type System</h1>
        <p>Understanding types, structs, unions, arrays, and enums</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="getting-started.html">Getting Started</a></li>
            <li><a href="features.html">Features</a></li>
            <li><a href="api-reference.html">API Reference</a></li>
            <li><a href="configuration.html">Configuration</a></li>
            <li><a href="examples.html">Examples</a></li>
            <li><a href="downloads.html">Downloads</a></li>
            <li><a href="about.html">About</a></li>
        </ul>
    </nav>

    <main>
        <section class="section">
            <h2>Type System Overview</h2>
            <p>Numstore provides a comprehensive type system for storing structured data:</p>
            <pre><code>TYPE = STRUCT | UNION | ARRAY | PRIMITIVE | ENUM</code></pre>
        </section>

        <section class="section">
            <h2>Primitive Types</h2>
            <p>Numstore supports a wide range of primitive types:</p>

            <h3>Signed Integers</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Size</th>
                    <th>Range</th>
                </tr>
                <tr>
                    <td>i8</td>
                    <td>1 byte</td>
                    <td>-128 to 127</td>
                </tr>
                <tr>
                    <td>i16</td>
                    <td>2 bytes</td>
                    <td>-32,768 to 32,767</td>
                </tr>
                <tr>
                    <td>i32</td>
                    <td>4 bytes</td>
                    <td>-2³¹ to 2³¹-1</td>
                </tr>
                <tr>
                    <td>i64</td>
                    <td>8 bytes</td>
                    <td>-2⁶³ to 2⁶³-1</td>
                </tr>
            </table>

            <h3>Unsigned Integers</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Size</th>
                    <th>Range</th>
                </tr>
                <tr>
                    <td>u8</td>
                    <td>1 byte</td>
                    <td>0 to 255</td>
                </tr>
                <tr>
                    <td>u16</td>
                    <td>2 bytes</td>
                    <td>0 to 65,535</td>
                </tr>
                <tr>
                    <td>u32</td>
                    <td>4 bytes</td>
                    <td>0 to 2³²-1</td>
                </tr>
                <tr>
                    <td>u64</td>
                    <td>8 bytes</td>
                    <td>0 to 2⁶⁴-1</td>
                </tr>
            </table>

            <h3>Floating Point</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Size</th>
                    <th>Precision</th>
                </tr>
                <tr>
                    <td>f16</td>
                    <td>2 bytes</td>
                    <td>Half precision</td>
                </tr>
                <tr>
                    <td>f32</td>
                    <td>4 bytes</td>
                    <td>Single precision</td>
                </tr>
                <tr>
                    <td>f64</td>
                    <td>8 bytes</td>
                    <td>Double precision</td>
                </tr>
                <tr>
                    <td>f128</td>
                    <td>16 bytes</td>
                    <td>Quadruple precision</td>
                </tr>
            </table>

            <h3>Complex Numbers</h3>
            <p>Complex integer types:</p>
            <ul>
                <li>ci16, ci32, ci64, ci128, ci256</li>
            </ul>
            <p>Complex unsigned types:</p>
            <ul>
                <li>cu16, cu32, cu64, cu128, cu256</li>
            </ul>
            <p>Complex floating point types:</p>
            <ul>
                <li>cf32, cf64, cf128, cf256</li>
            </ul>
        </section>

        <section class="section">
            <h2>Struct Types</h2>
            <p>Structs are composite types that group multiple fields together:</p>
            <pre><code>struct {
    field_a TYPE,
    field_b TYPE,
    ...
}</code></pre>

            <h3>Example</h3>
            <pre><code># Create a 2D point
create point struct { x f64, y f64 }

# Create a more complex struct
create person struct {
    id i32,
    age u8,
    salary f64,
    active u8
}</code></pre>
        </section>

        <section class="section">
            <h2>Union Types</h2>
            <p>Unions represent variant types where only one variant is active at a time:</p>
            <pre><code>union {
    variant_a TYPE,
    variant_b TYPE,
    ...
}</code></pre>

            <h3>Example</h3>
            <pre><code>create value union {
    int_val i32,
    float_val f64,
    str_val [256] u8
}</code></pre>
        </section>

        <section class="section">
            <h2>Array Types</h2>
            <p>Fixed-size arrays of any type:</p>
            <pre><code>[NUM] TYPE</code></pre>

            <h3>Examples</h3>
            <pre><code># Array of 10 integers
create numbers [10] i32

# Array of structs
create points [100] struct { x f64, y f64 }

# Multi-dimensional array (array of arrays)
create matrix [10] [10] f64</code></pre>
        </section>

        <section class="section">
            <h2>Enum Types</h2>
            <p>Enumerated types for representing discrete values:</p>
            <pre><code>enum {
    VARIANT_A,
    VARIANT_B,
    ...
}</code></pre>

            <h3>Example</h3>
            <pre><code>create status enum {
    PENDING,
    ACTIVE,
    COMPLETED,
    FAILED
}</code></pre>
        </section>

        <section class="section">
            <h2>Nested Types</h2>
            <p>Types can be arbitrarily nested:</p>
            <pre><code># Struct containing arrays and nested structs
create complex struct {
    id i32,
    position struct { x f64, y f64, z f64 },
    velocity struct { vx f64, vy f64, vz f64 },
    readings [100] f64,
    metadata union {
        text [256] u8,
        numeric f64
    }
}</code></pre>
        </section>

        <section class="section">
            <h2>Type Operations</h2>
            <p>Once you define a typed variable, all operations respect the type:</p>
            <ul>
                <li>Data is stored in packed binary format according to the type</li>
                <li>Field accessors allow reading specific struct fields</li>
                <li>Array indexing works naturally with fixed-size arrays</li>
                <li>Type checking ensures data integrity</li>
            </ul>
        </section>

        <section class="section">
            <h2>Vocabulary</h2>
            <h3>Variable</h3>
            <p>A named container for typed data. Variables store arrays of elements of a specific type.</p>

            <h3>Type</h3>
            <p>A specification defining the structure and size of data. Types can be primitive or composite.</p>

            <h3>Array</h3>
            <p>In Numstore, "array" has two meanings:</p>
            <ul>
                <li><strong>Type-level arrays</strong> - Fixed-size arrays as part of a type definition (e.g., <code>[10] i32</code>)</li>
                <li><strong>Variable arrays</strong> - The dynamic collection of elements stored in a variable</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>Copyright 2025 Theo Lincke | Licensed under the Apache License 2.0</p>
        <p><a href="https://gitlab.com/lincketheo/numstore">GitHub Repository</a></p>
    </footer>
</body>
</html>
